#! /bin/bash
# small and easy gmail fetcher script

set -e

version=0.3-git
maintainer="@ 2013 Marko Rakamaric"

usage(){
cat << EOF  
Usage: gfetch <action>
	 
${G}Daemon actions:${N}	
  ${W}-D --daemon${N}      start daemon
  ${W}-k --kill${N}        kill gfetch

${G}Standard actions:${N}	
  ${W}(c)heck${N}          check mail
  ${W}(l)ist${N}           list mails
EOF
}

version(){
cat << EOF
     This is  : gfetch
     Version  : $version
 Description  : Mail retriver and checker for Gmail
   Copyright  : $maintainer
     License  : GNU General Public License, version 3 or later
EOF
}

#osd_show_sender_email=0

msg(){ printf "%s\n" "$@"; } # color noraml
die(){ exit "$?"; } # exit 

# define some colors
W="$(tput bold)$(tput setaf 7)"
R="$(tput bold)$(tput setaf 1)"
G="$(tput bold)$(tput setaf 2)"
Y="$(tput bold)$(tput setaf 3)"
N="$(tput sgr0)"

_replace_unwanted_characters_(){
		# format html: &lt,&gt;$amp;&quot
		local sub="${1}"
		subject=$(echo "$subject" | sed -e "s|&quot;|\"|g" -e "s|&lt;|<|g" -e "s|&gt;|>|g" -e "s|&amp;|&|g")	
}

_shrink_subject_(){
		local sub="${1}"

		[[ ${#sub} -gt $max_subject_size ]] && \
			subject=$(echo "$sub" | sed "s|.\{$max_subject_size\}|&\n|g")
		return
}

_strip_html_tags_(){
		
		subject=$(echo $subject| sed "s/<title>//" | sed "s|</title>||") 
		sender=$(echo $sender| sed "s/<name>//" | sed "s|</name>||" ) 
		email=$(echo $email | sed "s/<email>//" | sed "s|</email>||" ) 
}

is_running(){ [[ -f $1 ]] && return 0 || return 1 ; }

rm_obsolte(){	for i in $tmpdir/*; do 	rm $i; done; }

kill_daemon(){ rm_obsolte; pkill gfetch; }

d_err(){ [[ $1 = 1 ]] && msg "${R}!!! Error:${N} $0 daemon already running" && die || msg "${R}!!! Error:${N} $0 isn't started" && die; }

get_pid(){ ! [[ -f $pid ]] && echo $$ > $pid || return 0; }

readcfg(){
	
		if [[ -f $cfg ]]; then
			source $cfg 
		else
			msg "${R}*${N} No config file, please copy default to ${W}$HOME${N}" && die 
		fi
}

network_carrier_status(){
	# we don't wana start gmailfetcher system is not online
	hwactive=$( route -n | awk '{print $8}' | sed '/^$/d' | grep -v "\Iface\|lo" | uniq )
	! [[ $hwactive ]] && return
	[[ $( cat /sys/class/net/$hwactive/carrier ) = 1 ]] && online="true"

}

checkmail(){
	readcfg

  [[ -f $mail ]] && mv "$mail" "$_mail"
	
	wget -q --secure-protocol=TLSv1 --no-check-certificate --user=$user --password=$pass https://mail.google.com/mail/feed/atom -O - | \
	grep -ioE "<name[^>]*>[^<]*</name>|<title[^>]*>[^<]*</title>|<email[^>]*>[^<]*</email>" | sed 1d > $mail
	
  [[ ! $force  ]] && if [[ -f $_mail ]]; then diff "$mail" "$_mail" && return; fi
	mailcount=$( expr $(wc -l $mail | awk '{print $1}') / 3  )	
	omailcount=$( expr $(wc -l $_mail | awk '{print $1}') / 3 ) 
 
  if [[ $mailcount -ge 0 ]]; then

		# if we have 0 mails, redirect mailcount to $mcout
      echo -e $mailcount > "$mcount"

    if [[ $mailcount -gt 0 ]]; then
			
      echo -e $mailcount > "$mcount"

			# passing cmdline c to force check
			[[ $force ]] && msg " ${G}*${N} You have ${W}$( cat $mcount )${N} new mails" && die

			# don't show notify or sound if we already readed some mails
			[[ $iter -gt 1 ]] &&	[[ $mailcount -lt $omailcount ]] && osd="false" && sound="false" 

	    if [[ $osd = "true" ]] && [[ ! $force ]]; then
						
				
				while read -r subject; read -r sender; read -r email; do
						
						_strip_html_tags_
						_replace_unwanted_characters_ "$subject"
						_shrink_subject_
						
						(( $osd_show_sender_email )) && email=("<${email}>") || email=""

						notify-send -t "$osd_timeout" "$osdtext [$mailcount]" \
							"\nFrom: <b>$sender</b> $email\nSubject: $subject"	
					done < <(sed -n 1,3p $mail )

	    fi	  
    
			if [[ $sound = "true" && -f "$wav" ]] && [[ ! $force ]];then 
				 aplay "$wav" &> /dev/null
			fi

		fi
  
	else
		# we need some kind of info when we have some Err while fetching
    echo -e "Err" > "$mcount"
  fi
}

output_align(){
	# lcolumn(left colum max width), 
	# space(blank space between left and right column)
	local action="${#1}" space=10 lcolumn=20
	indent=$( expr $lcolumn - $action + $space )
}

write_list_output(){ 
	local sender=${1} title=${2}
	
	[[ $lnb -lt 10 ]] && \
		printf "%s%-${indent}s%s\n" "  $W[$(( lnb++ ))]  ${G}${sender}${N}" "" "${title}" || \
		printf "%s%-${indent}s%s\n" " $W[$(( lnb++ ))]  ${G}${sender}${N}" "" "${title}"
	return 0
}


list_mail(){
	readcfg
	lnb=1
	# mailcount is devided by 2 because we store information for
	# <title> <name>
	mailcount=$( expr $(wc -l $mail | awk '{print $1}') / 3 )	

	if	[[ $mailcount -lt 1 ]] ; then 
		msg " ${Y}*${N} No new mails!" && die
	else
		newmail="true"
		msg " ${G}*${N} New mails for ${Y}"$mailbox"${N}" 
	fi

	while read -r subject; read -r sender; read -r email; do

		_strip_html_tags_
		_replace_unwanted_characters_ "$subject"

		! [[ -z $sender ]] && \
			output_align "$sender" && \
			write_list_output "$sender" "$subject" && \
			unset sender subject

	done < $mail

  [[ $newmail ]] && msg " ${Y}*${N} Total new mails: ${W}$lnb${N}" 
	
}

cfg="$HOME/.gfetchrc"
tmpdir="/tmp/gfetch"
mcount="$tmpdir/mcount"
mail="$tmpdir/newmails.txt"
_mail="$tmpdir/oldmails.txt"
pid="$tmpdir/gfetch.pid"

ARGS=("$@")
for i in ${ARGS[@]}; do
	[[ "$i" =~ ^[a-z] ]] && OPTS+=("$i")
	[[ "$i" =~ ^--[a-z] ]] && OPTS+=("$i")
	[[ "$i" =~ ^-[a-zA-Z] ]] && OPTS+=("$i")
done

! [[ -e $tmpdir  ]] && mkdir -p "$tmpdir"

[[ $# -lt 1 ]] && usage && die

case $OPTS in
  -D | --daemon  ) is_running $pid && d_err 1;
								   nohup $0 --config "$cfg" &> /dev/null & exit 1 ;;
	-k | --kill    ) ! is_running $pid && d_err 2 ;
								   kill_daemon ;;
	     --config  ) readcfg ;;
   c | check     ) ! is_running $pid && d_err 2;
									 force="true"; checkmail && die;;
	 l | list      ) ! is_running $pid && d_err 2;
									 list_mail && die ;;
	-v | --version ) version && die ;;
							 * ) msg " ${R}*${N} Unerocgnized command!!" && die ;;
esac

iter=0
while true; do
	
	 get_pid	
	 network_carrier_status
	 [[ $online ]] && checkmail && sleep ${interval:=300} || iter=0 && sleep 10 

iter=$((iter+1))
done 
